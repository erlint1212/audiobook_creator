import html
import json
import os
import re
import sys
import uuid

from ebooklib import epub


def create_xhtml_chapter(chapter_title, text_content, chapter_file_name_base):
    """
    Converts plain text content to a simple XHTML chapter object.
    """
    file_name = f"{chapter_file_name_base}.xhtml"
    chapter = epub.EpubHtml(title=chapter_title, file_name=file_name, lang="en")

    # Create HTML content
    escaped_title = html.escape(chapter_title)
    xhtml_content_parts = [f"<h1>{escaped_title}</h1>"]

    # Split by blank lines to form paragraphs
    # Handle various line ending types
    paragraphs = re.split(r"\n\s*\n+", text_content.strip())

    for para_text in paragraphs:
        cleaned_para = para_text.strip()
        if cleaned_para:
            escaped_para = html.escape(cleaned_para)
            # Preserve internal line breaks within a paragraph
            escaped_para = escaped_para.replace("\r\n", "<br />\n").replace(
                "\n", "<br />\n"
            )
            xhtml_content_parts.append(f"<p>{escaped_para}</p>")

    chapter.content = "\n".join(xhtml_content_parts)
    return chapter


def create_epub_project():
    # --- CRITICAL FIX FOR WINDOWS UNICODE ERROR ---
    # Forces the console output to use UTF-8 instead of the default Windows cp1252
    if sys.platform == "win32":
        sys.stdout.reconfigure(encoding="utf-8")

    print("--- Starting EPUB Creation ---")

    # --- 1. Setup Paths ---
    # The GUI passes 'EPUB_INPUT_DIR' (e.g., Novels/MyBook/01_Raw_Text)
    # The GUI passes 'EPUB_OUTPUT_FILE' (e.g., Novels/MyBook/MyBook.epub)

    TEXT_INPUT_DIR = os.getenv("EPUB_INPUT_DIR")
    OUTPUT_FILE = os.getenv("EPUB_OUTPUT_FILE")

    # Standalone fallback (for testing without GUI)
    if not TEXT_INPUT_DIR:
        print("Warning: Running standalone. Using default relative paths.")
        TEXT_INPUT_DIR = "BlleatTL_Novels"
        OUTPUT_FILE = "Output.epub"

    if not os.path.exists(TEXT_INPUT_DIR):
        print(f"Error: Input directory not found: {TEXT_INPUT_DIR}")
        return

    # Determine Project Root (One level up from text dir)
    # If text dir is ".../Novels/Title/01_Raw_Text", root is ".../Novels/Title"
    PROJECT_ROOT = os.path.dirname(os.path.abspath(TEXT_INPUT_DIR))

    METADATA_JSON = os.path.join(PROJECT_ROOT, "metadata.json")
    COVER_IMAGE = os.path.join(PROJECT_ROOT, "cover.jpg")
    CHAPTERS_JSON = os.path.join(TEXT_INPUT_DIR, "chapters.json")

    # --- 2. Load Metadata ---
    # Default values
    book_meta = {
        "title": os.getenv("EPUB_TITLE", "Unknown Title"),
        "author": "Unknown Author",
        "description": "Generated by Auto-Audiobook Pipeline",
    }

    # Override with metadata.json if exists
    if os.path.exists(METADATA_JSON):
        print(f"Loading metadata from: {METADATA_JSON}")
        try:
            with open(METADATA_JSON, "r", encoding="utf-8") as f:
                loaded_meta = json.load(f)
                # Only update keys that contain data
                if loaded_meta.get("title"):
                    book_meta["title"] = loaded_meta["title"]
                if loaded_meta.get("author"):
                    book_meta["author"] = loaded_meta["author"]
                if loaded_meta.get("description"):
                    book_meta["description"] = loaded_meta["description"]
        except Exception as e:
            print(f"Warning: Failed to parse metadata.json: {e}")

    # Safe Print to avoid crash if reconfigure fails for some reason
    try:
        print(f"Book Title: {book_meta['title']}")
        print(f"Book Author: {book_meta['author']}")
    except UnicodeEncodeError:
        print(f"Book Author: [Complex Characters Hidden]")

    # --- 3. Setup EPUB Book Object ---
    book = epub.EpubBook()
    book.set_identifier(str(uuid.uuid4()))
    book.set_title(book_meta["title"])
    book.set_language("en")
    book.add_author(book_meta["author"])

    if book_meta["description"]:
        book.add_metadata("DC", "description", book_meta["description"])

    # Handle Cover
    if os.path.exists(COVER_IMAGE):
        try:
            with open(COVER_IMAGE, "rb") as f:
                book.set_cover("cover.jpg", f.read())
            print(f"Attached cover image: {COVER_IMAGE}")
        except Exception as e:
            print(f"Error attaching cover: {e}")
    else:
        print("No cover.jpg found in project root.")

    # --- 4. Load Chapter Order ---
    chapter_entries = []

    # Try loading strictly ordered list from scraper
    if os.path.exists(CHAPTERS_JSON):
        try:
            with open(CHAPTERS_JSON, "r", encoding="utf-8") as f:
                data = json.load(f)
                chapter_entries = [entry for entry in data if entry.get("file")]
            print(f"Loaded order from chapters.json ({len(chapter_entries)} chapters)")
        except Exception as e:
            print(f"Error loading chapters.json: {e}")

    # Fallback: Alphabetical sort of text files
    if not chapter_entries:
        print("Falling back to alphabetical file sort.")
        txt_files = sorted(
            [f for f in os.listdir(TEXT_INPUT_DIR) if f.lower().endswith(".txt")]
        )
        chapter_entries = [{"file": f} for f in txt_files]

    if not chapter_entries:
        print("No .txt files found to compile.")
        return

    # --- 5. Process Chapters ---
    epub_chapters = []
    toc_links = []

    print(f"Processing text files...")
    for i, entry in enumerate(chapter_entries):
        txt_filename = entry["file"]
        txt_filepath = os.path.join(TEXT_INPUT_DIR, txt_filename)

        if not os.path.exists(txt_filepath):
            print(f"  [Skipped] Missing file: {txt_filename}")
            continue

        try:
            with open(txt_filepath, "r", encoding="utf-8") as f:
                lines = f.readlines()
                if not lines:
                    continue

                # Heuristic: The first line is often the Title (saved by scraper)
                # If the first line is very short, treat it as title. Otherwise default.
                first_line = lines[0].strip()
                if len(first_line) < 200:
                    final_title = first_line
                    body_content = "".join(lines[1:]).strip()
                else:
                    final_title = f"Chapter {i+1}"
                    body_content = "".join(lines).strip()

            # Create XHTML Chapter Object
            chapter_obj = create_xhtml_chapter(
                final_title, body_content, f"chapter_{i+1:04d}"
            )
            book.add_item(chapter_obj)
            epub_chapters.append(chapter_obj)
            toc_links.append(
                epub.Link(chapter_obj.file_name, final_title, f"chapter_{i+1:04d}")
            )

        except Exception as e:
            print(f"  [Error] Failed to process {txt_filename}: {e}")

    # --- 6. Finalize EPUB ---
    book.toc = tuple(toc_links)
    book.add_item(epub.EpubNcx())
    book.add_item(epub.EpubNav())

    # CSS Styling
    css = """
    body { margin: 5%; font-family: serif; font-size: 1.1em; line-height: 1.6; }
    h1 { text-align: center; margin-top: 2em; margin-bottom: 1em; font-weight: bold; border-bottom: 1px solid #ddd; padding-bottom: 0.5em;}
    p { text-indent: 1.5em; margin-bottom: 0.5em; text-align: justify; }
    """
    style_item = epub.EpubItem(
        uid="style_default",
        file_name="style/default.css",
        media_type="text/css",
        content=css,
    )
    book.add_item(style_item)

    book.spine = ["nav"] + epub_chapters
    for ch in epub_chapters:
        ch.add_item(style_item)

    # Write file
    try:
        epub.write_epub(OUTPUT_FILE, book, {})
        print(f"SUCCESS! EPUB saved to: {OUTPUT_FILE}")
    except Exception as e:
        print(f"Error saving EPUB file: {e}")


if __name__ == "__main__":
    create_epub_project()
